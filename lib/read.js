var check = require('./util/check')
var isTypedArray = require('./util/is-typed-array')

var GL_RGBA = 6408
var GL_UNSIGNED_BYTE = 5121
var GL_PACK_ALIGNMENT = 0x0D05

module.exports = function wrapReadPixels (
  gl,
  framebufferState,
  reglPoll,
  context,
  glAttributes) {
  function readPixels (input) {
    if (framebufferState.current === null) {
      check(
        glAttributes.preserveDrawingBuffer,
        'you must create a webgl context with "preserveDrawingBuffer":true in order to read pixels from the drawing buffer')
    } else {
      // TODO check framebuffer supports read pixels
    }

    var x = 0
    var y = 0
    var width = context.framebufferWidth
    var height = context.framebufferHeight
    var data = null

    if (isTypedArray(input)) {
      data = input
    } else if (input) {
      check.type(input, 'object', 'invalid arguments to regl.read()')
      x = input.x | 0
      y = input.y | 0
      check(
        x > 0 && x < context.framebufferWidth,
        'invalid x offset for regl.read')
      check(
        y > 0 && y < context.framebufferHeight,
        'invalid y offset for regl.read')
      width = (input.width || (context.framebufferWidth - x)) | 0
      height = (input.height || (context.framebufferHeight - y)) | 0
      data = input.data || null
    }

    check(
      width > 0 && width + x <= context.framebufferWidth,
      'invalid width for read pixels')
    check(
      height > 0 && height + y <= context.framebufferHeight,
      'invalid height for read pixels')

    // Update WebGL state
    reglPoll()

    // TODO:
    //  float color buffers
    //  implementation specific formats

    // Compute size
    var size = width * height * 4

    // Allocate data
    data = data || new Uint8Array(size)

    // Type check
    check.isTypedArray(data, 'data buffer for regl.read() must be a typedarray')
    check(data.byteLength >= size, 'data buffer for regl.read() too small')

    // Run read pixels
    gl.pixelStorei(GL_PACK_ALIGNMENT, 4)
    gl.readPixels(x, y, width, height, GL_RGBA, GL_UNSIGNED_BYTE, data)

    return data
  }

  return readPixels
}
